\section{Mikroszerviz infrastruktúra}

\subsection{Nginx}
Az nginxnek három elkülönülő szerepe van:

\begin{itemize}
	\item{A \foreignlanguage{british}{helpdesk frontend} alkalmazásszervereként működik (lásd \ref{sec:angular} pont)}
	
	\item{\foreignlanguage{british}{Routing}ot valósít meg, rajta kerestül érhető el a \foreignlanguage{british}{helpdesk backend} és a \foreignlanguage{british}{keycloak} szerviz}
	
	\item{\foreignlanguage{british}{HTTP cahce}-ként működik a frontend és a backend között, illetve a frontend és a keycloak között}
\end{itemize}

A loadbalancer funkcionalitás a \foreignlanguage{british}{docker round-robin DNS}-én (\ref{sec:docker}) keresztül valósul meg.


\subsection{Docker konténerizáció}\label{sec:docker}
Az alakalmazás összes szervize saját docker konténerben fut. A docker konfigurációs leírása a \textit{docker-compose.yml} állományban van. A \textit{docker-compose} parancs ez alapján indítja el az alkalmazást, hozza létre a saját alhálózatát, valósítja meg a hálózaton belüli DNS-funkciót.

A konténerek skálázása  is a dockeren keresztül (\textit{docker-compose --scale}) valósul meg.



\subsection{Metrikák}
A springes alkamazásaim egy-egy HTTP endpointon keresztül érhetőek el a prometheus számára (\textit{\mbox{/actuator/proemtheus}}) és induláskor beregisztrálják magukat az eureka\footnote{Az Eureka a Netflix által fejlesztett \textit{discovery server}. Feladata az összes kliens port és ip adatának nyilkvántartása.} szerverbe.

A prometheus\footnote{A Prometheus egy open source monitorozó eszköz. 15 másodpercenként lekérdezi a szervizek állapotát.} az eurekán keresztül találja meg az instanceokat, és gyűjti össze a metrikákat. Az alkalmazások információt küldenek a Kafka konnektorukról, REST interfészükről és az adatbázis kapcsolatukról\footnote{HikariCP-t használok JDBC kapcsolathoz}.

A Prometheus által összegyűjtött adatokat grafanában\footnote{A Grafana egy open source elemző és megjelenítő web alkalmazés} ábrázolom.






\section{E-mail kliens}
Az e-mail kliens szerepe az üzenetek küldése és fogadása egy meghatározott e-mail címről. Feladata a külső protokollok leválasztása az alkalmazástól. Irányítja és karbantartja az IMAP és SMTP szerverrel való kapcsolatot.

A két irányú kommunikáció megvalósulása:
\begin{itemize}
	\item az IMAP-on keresztül fogadott e-mailt az \textit{email.in.v1.pub} kafka topicba írja,
	\item a saját --e-mail cím specifikus-- topic-jából kiolvassa az üzenetet és továbbítja  az SMTP szerver felé.
\end{itemize}


\subsection{E-mail szabvány}
Az elküldött üzenetek megfelelnek az \textit{rfc5322} szabványnak, különös tekintettel a 3.6.4. pontban~\cite{rfc5322_Identification_Fields} meghatározott mezőkre:

\begin{description}
	\item[Message-ID] egy globálisan egyedi azonosító ami egyértelműen azonosítja az üzenetet,
	
	\item[In-Reply-To] válasz esetén értéke eredeti üzenet \textit{Message-ID}-ja,
	
	\item[References] azonosítja az üzenet szálat, értéke az eredeti üzenetek \textit{Message-ID}-jai vesszővel elválasztva.
\end{description}




\section{Helpdesk backend}
A backend felelős az e-mail szálakkal kapcsolatos üzleti feladatok ellátásáért:
\begin{itemize}
	\item kiszolgálja a frontendet REST protokollon keresztül,
	\item tárolja az e-mail szálakkal kapcsolatos adatokat,
	\item  fogadja az \textit{email.in.v1.pub} kafka topic-ból érkező e-maileket, és a megfelelő kafka topic-ba írja az elküldendő üzeneteket.
\end{itemize}


\subsection{Spring Boot}
A forráskód Spring Boot (\ref{sec:spring_boot} pont) keretrendszerrel készült. Az elérhető modulok közül a data-jpa-t az adatbázis \textit{repository}-jaihoz, a security-t a keycloak integrációhoz, a webet a \textit{rest controller}ekhez, a prometheus-t és az actuatort a metrikák elkészítéséhez használtam.	


\subsection{Adatbázis}
PostgreSQL adatbázishoz kapcsolódást a HikariCP-n keresztül a Spring kezeli.
Az adatok kezelését Hibernate\footnote{A Hibernate egy JPA implementáció, ami objektum relációs leképzést valósít meg}-en keresztül, az adatbázis verziókövetését Liquibase-en keresztül valósítom meg. 

Az e-mail szálak audit információinak és verzióinak követésére a Hibernate Envers eszközét használom. Az Envers a neki létrehozott táblában automatikusan követi a megjelölt Hibernate objektumok állapotát.

\subsection{Egyéb eszközök}\label{sec:backend_egyeb_eszkozok}
A \textit{DTO}-k és az \textit{entity}k közötti leképezést a Mapstruct (\ref{sec:retegek_szeparalasa}) segítségével végzem. A REST \textit{endpoint}ok dokumentációját Swagger segítségével generálom. A Swagger a felannotált osztályokból és metódusokból szabványos OpenApi dokumnetációt készít.




\section{Helpdesk frontend}
A frontend az e-mailek és e-mail szálakkal összefüggő üzelti feladatok megjelenítéséért felelős. A felhasználók jogosultság ellenőrzését végzi el, a bejelentkeztetésüket átirányítja a Keycloak szervernek. 


\subsection{Kommunikáció a backenddel}
A backenddel való kommunikáció REST protokollon keresztül zajlik, a szükséges \textit{service}-eket az OpenApi dokumnetációból (\ref{sec:backend_egyeb_eszkozok}) a \textit{swagger angular generator} hozza létre.

Az aszinkron HTTP hívásokat az NgRx könyvtár alakítja adatfolyamokká. 
Az így \textit{Observable}-ként kezelt események már támogatják a stream műveleteket, könnyen filterezhetőek és nagyban megkönnyítik az egységes hibakezelést. 

Az NgRx használatával továbbá, elkerülhetőek az aszinkron hívások mellékhatásai, és egy globális, alkalmazás szintű állapot hozható létre.

\subsection{Komponensek}
Az egységes 
	

material 
egységes look and feel, legtöbb amire szükségem van készen van,
sok felhasználónak ismerős felület


 quill
jól integrálható angularba, sok funkciója van, open source


\subsection{deploymnet}
\ref{sec:angular}
static html-lé fordul a kliens oldalán fut a frontend






\section{keycloak}	
\subsection{JWT-token}
\subsection{role-ok}
\subsection{admin felületről valami?}