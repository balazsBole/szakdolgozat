Szeretném külön-külön bemutatni az egyes komponenseket. Kiemelni a komponensek által megvalósított funkciókat, és a megvalósítás szempontjából fontos részleteket. 

\section{Mikroszerviz infrastruktúra}
\subsection{Nginx}\label{sec:nginx}
Az nginxnek három elkülönülő szerepe van:

\begin{itemize}
	\item{A \foreignlanguage{british}{helpdesk frontend} alkalmazásszervereként működik (lásd \ref{sec:angular} pont)}
	
	\item{\foreignlanguage{british}{Routing}ot valósít meg, rajta kerestül érhető el a \foreignlanguage{british}{helpdesk backend} és a \foreignlanguage{british}{keycloak} szerviz}
	
	\item{\foreignlanguage{british}{HTTP cahce}-ként működik a frontend és a backend között, illetve a frontend és a keycloak között}
\end{itemize}

A loadbalancer funkcionalitás a \foreignlanguage{british}{docker round-robin DNS}-én (\ref{sec:docker}) keresztül valósul meg.


\subsection{Docker konténerizáció}\label{sec:docker}
Az alakalmazás összes szervize saját docker konténerben fut. A docker konfigurációs leírása a \textit{docker-compose.yml} állományban van. A \textit{docker-compose} parancs ez alapján indítja el az alkalmazást, hozza létre a saját alhálózatát, valósítja meg a hálózaton belüli DNS-funkciót.

A konténerek skálázása  is a dockeren keresztül (\textit{docker-compose --scale}) valósul meg.



\subsection{Metrikák}\label{sec:metrikak}
A springes alkamazásaim egy-egy HTTP endpointon keresztül érhetőek el a prometheus számára (\textit{\mbox{/actuator/proemtheus}}) és induláskor beregisztrálják magukat az eureka\footnote{Az Eureka a Netflix által fejlesztett \textit{discovery server}. Feladata az összes kliens port és ip adatának nyilkvántartása.} szerverbe.

A prometheus\footnote{A Prometheus egy open source monitorozó eszköz. 15 másodpercenként lekérdezi a szervizek állapotát.} az eurekán keresztül találja meg az instanceokat, és gyűjti össze a metrikákat. Az alkalmazások információt küldenek a Kafka konnektorukról, REST interfészükről és az adatbázis kapcsolatukról\footnote{HikariCP-t használok JDBC kapcsolathoz}.

A Prometheus által összegyűjtött adatokat grafanában\footnote{A Grafana egy open source elemző és megjelenítő web alkalmazés} ábrázolom.






\section{E-mail kliens}
Az e-mail kliens szerepe az üzenetek küldése és fogadása egy meghatározott e-mail címről. Feladata a külső protokollok leválasztása az alkalmazástól. Irányítja és karbantartja az IMAP és SMTP szerverrel való kapcsolatot.

\Aref{fig:email-client_sequence_diagram}. ábrán látható a két irányú kommunikáció megvalósulása:
\begin{itemize}
	\item az IMAP-on keresztül fogadott e-mailt az \textit{email.in.v1.pub} kafka topicba írja,
	\item a saját --e-mail cím specifikus-- topic-jából kiolvassa az üzenetet és továbbítja  az SMTP szerver felé.
\end{itemize}


\begin{figure}[hbt] 
	\centering
	\includegraphics[width=0.85\textwidth]{email-client_sequence_diagram_drawio.pdf}
	\caption{E-mail kliens szekvencia diagramja}
	\label{fig:email-client_sequence_diagram}
	\floatfoot{Forrás: saját ábra}
\end{figure}




\subsection{E-mail szabvány}
Az elküldött üzenetek megfelelnek az \textit{rfc5322} szabványnak, különös tekintettel a 3.6.4. pontban~\cite{rfc5322_Identification_Fields} meghatározott mezőkre:

\begin{description}
	\item[Message-ID] egy globálisan egyedi azonosító ami egyértelműen azonosítja az üzenetet,
	
	\item[In-Reply-To] válasz esetén értéke eredeti üzenet \textit{Message-ID}-ja,
	
	\item[References] azonosítja az üzenet szálat, értéke az eredeti üzenetek \textit{Message-ID}-jai vesszővel elválasztva.
\end{description}




\section{Helpdesk backend}\label{sec:backend}
A backend felelős az e-mail szálakkal kapcsolatos üzleti feladatok ellátásáért. \Aref{fig:backend_sequence_diagram}. ábrán láthatóak a helpdesk backend funkciói:
\begin{itemize}
	\item fogadja az \textit{email.in.v1.pub} kafka topic-ból érkező e-maileket, 
	\item kiszolgálja a frontend Nginx-en keresztül érkező kéréseit,
	\item a megfelelő kafka topic-ba írja az elküldendő üzeneteket,
	\item tárolja az e-mail szálakkal kapcsolatos adatokat.
\end{itemize}


\begin{figure}[hbt] 
	\centering
	\includegraphics[width=0.85\textwidth]{backend_sequence_diagram_drawio.pdf}
	\caption{Helpdesk backend szekvencia diagramja}
	\label{fig:backend_sequence_diagram}
	\floatfoot{Forrás: saját ábra}
\end{figure}


\subsection{Spring Boot}
A forráskód Spring Boot (\ref{sec:spring_boot} pont) keretrendszerrel készült. Az elérhető modulok közül a data-jpa-t az adatbázis \textit{repository}-jaihoz, a security-t a keycloak integrációhoz, a webet a \textit{rest controller}ekhez, a prometheus-t és az actuatort a metrikák elkészítéséhez használtam.	


\subsection{Adatbázis}\label{sec:adatbazis}
PostgreSQL adatbázishoz kapcsolódást a HikariCP-n keresztül a Spring kezeli.
Az adatok kezelését Hibernate\footnote{A Hibernate egy JPA implementáció, ami objektum relációs leképzést valósít meg}-en keresztül, az adatbázis verziókövetését Liquibase-en keresztül valósítom meg. 

Az e-mail szálak audit információinak és verzióinak követésére a Hibernate Envers eszközét használom. Az Envers a neki létrehozott táblában automatikusan követi a megjelölt Hibernate objektumok állapotát.

\subsection{Egyéb eszközök}\label{sec:backend_egyeb_eszkozok}
A \textit{DTO}-k és az \textit{entity}k közötti leképezést a Mapstruct (\ref{sec:retegek_szeparalasa}) segítségével végzem. A REST \textit{endpoint}ok dokumentációját Swagger segítségével generálom. A Swagger a felannotált osztályokból és metódusokból szabványos OpenApi dokumnetációt készít.




\section{Helpdesk frontend}
A frontend az e-mailek és e-mail szálakkal összefüggő üzleti feladatok megjelenítéséért felelős. A felhasználók jogosultság ellenőrzését végzi el, a bejelentkeztetésüket átirányítja a Keycloak szervernek. 


\subsection{Kommunikáció a backenddel}
A backenddel való kommunikáció REST protokollon keresztül zajlik, a szükséges \textit{service}-eket az OpenApi dokumnetációból (\ref{sec:backend_egyeb_eszkozok}) a \textit{swagger angular generator} hozza létre.

Az aszinkron HTTP hívásokat az NgRx könyvtár alakítja adatfolyamokká. 
Az így, \textit{Observable}-ként kezelt események már támogatják a stream műveleteket, megkönnyítik a filterezhetőséget és az egységes hibakezelést. 

Az NgRx használatával továbbá, elkerülhetőek az aszinkron hívások mellékhatásai, és egy globális, alkalmazás szintű belső állapot hozható létre.

\subsection{Komponensek}
Az egységes megjelenés és az ismerős kinézet miatt, a komponenseim alapjának az Angular Material UI könyvtárat választottam. A könyvtár	népszerű az Angular fejlesztők körében, mert a leggyakrabban előforduló felhasználói igényekre elérhető benne kész, könnyen használható megoldás.

A válasz e-mail lérehozására az open source Quill szövegszerkesztőt használtam.
Egyszerűen beilleszthető az Angular környezetbe, és a felhasználó számára intuitív kezelőfelülettel rendelkezik.


\subsection{Futtatási környezet}
A kész program egy egyszerű HTML, CSS és JavaScript állománnyá fordul. A körülbelül $1,5$~MB-nyi forráskódot elegendő a böngészőbe egyszer letölteni, onnantól a program a kliens oldalon fut (lásd \ref{fig:frontend_sequence_diagram} ábra). A backend felé induló REST kéréseket a loadbalancer (\ref{sec:nginx}) osztja szét a rendelkezésre álló példányok között.

A frontend működését, és függőségeit \aref{fig:frontend_sequence_diagram}. ábra tartalmazza.

\begin{figure}[hbp] 
	\centering
	\includegraphics[width=0.85\textwidth]{frontend_sequence_diagram_drawio.pdf}
	\caption{Helpdesk frontend szekvencia diagramja}
	\label{fig:frontend_sequence_diagram}
	\floatfoot{Forrás: saját ábra}
\end{figure}


\section{Keycloak}\label{sec:keycloak}
A Keycloak egy open source jogosultság- és hozzáférés-kezelő. Támogatja az LDAP-ot, SSO-t és a kétlépcsős azonosítást~\cite{Keycloak_website}. 

A helpdesk alkalmazásban feladata a felhasználók azonosítása, és adataiknak nyilvántartása. Különálló mikroszervizként, saját adatbázissal rendelkezik.

Adminisztrátor felülete segítségével nyomon követhető a különböző autentikációhoz köthető események, szerkeszthetőek az aktuálisan érvényes szerepkörök, és --hibakezelési céllal-- megszemélyesíthetőek a felhasználók.


\subsection{Jogosultságkezelés}
A jogosultságokat két eltérő területre osztottam fel. A \textit{master realm} a regisztrációért és a jogkörök kiosztásáért, míg a \textit{helpdesk realm} az alakalmazás funkcionális (\ref{sec:tobb_felhasznalo}) feladatiért felelős.

A \textit{helpdesk realm}on belül további két jogkört külöböztetek meg. Az \textit{admin\textunderscore user} szerepbe tartozó felhasználók képesek más e-mail szálait is kezelni, míg a csupán \textit{regular\textunderscore user} jogkörbe tartozóak csak a saját e-mail szálaikhoz férhetnek hozzá.


\subsection{JSON Web Token}\label{sec:JWT}
A jogosultságkezelés technikai alapját az \textit{rfc7519}-es szabványban \cite{rfc7519_JSON_Web_Token} leírt JSON Web Token (JWT) adja. 

A keycloak szervere által digitálisan aláírt token tartalmazza a felhasználó jogosultságait. A frontend minden HTTP lekérdezéshez csatolja a keycloaktól kapott azonosítót. A backend hitelesíti a tokent a keycloak publikus kulcsával (lásd \ref{fig:frontend_sequence_diagram} ábra), és a megfelelő jogosultság megléte esetén engedélyezi a hozzáférést az erőforráshoz.


\section{Kafka}
Hogy teljesen elválasszam egymástól az e-mail klienst és a helpdesk backendet, a bejövő és kimenő e-mailek Kafka \textit{topic}-okon (\ref{sec:apache_kafka} pont) mennek keresztül. A szeparációval függetlenné teszem egymástól a két rendszer működését, ami lehetővé teszi az eltérő igénybevételnek (\ref{sec:granularitas} pont) megfelelő skálázhatóságot.




\section{Helpdesk backend és a Keycloak elkülönítése}
A felhasználók adataiért a Keycloak (\ref{sec:keycloak}), az e-mail szálakért pedig a backend (\ref{sec:backend}) felelős. Az üzleti igény megköveteli hogy a felhasználók e-mail sorokhoz, és az e-mail szálak felhasználókhoz legyenek rendelve. A helpdesk backendnek éppen ezért tárolnia kell a fennálló kapcsolatot.

A felhasználó Keycloaktól kapott egyedi azonosítóját tárolom a backenden. Ez alapján azonosítom a JSON Web Tokenben (\ref{sec:JWT}) érkező felhasználót.

A felhasználók bejelentkezésről értesül a backend és eltárolja az új felhasználók egyedi adatait. Ez a megoldás addig használható, míg a felhasználókról tárolt mezők nem változnak meg, és a felhasználók nem törölhetőek. Amint ezek a feltételek megváltoznak, vagy  más, felhasználókkal kapcsolatos igények jelennek meg, akkor \aref{sec:alkalmazasok_szeparalasa} pontban megismertetett CQRS utat kell megvalósítani.
	

A Keycloakban regisztrálni kell egy Kafka event providert, és a kafka \textit{topic}on  keresztül kell követni a felhasználók adatait. Ezzel is elválasztva egymástól a két mikroszerviz működését.

